<!-- TOC -->

- [第四章 表达式](#第四章-表达式)
    - [4.1 基础](#41-基础)
        - [4.1.1 基本概念](#411-基本概念)
        - [4.1.2 优先级和结合律](#412-优先级和结合律)
        - [4.1.3 求值顺序](#413-求值顺序)
    - [4.2 算术运算符](#42-算术运算符)
        - [练习4.6 一个表达式判断一个数是奇数还是偶数](#练习46-一个表达式判断一个数是奇数还是偶数)
        - [练习4.7 三条导致溢出的语句](#练习47-三条导致溢出的语句)
    - [4.3 逻辑和关系运算符](#43-逻辑和关系运算符)
        - [逻辑与，逻辑或](#逻辑与逻辑或)
        - [关系运算符](#关系运算符)
    - [4.4 赋值运算符](#44-赋值运算符)
        - [赋值运算满足右结合律](#赋值运算满足右结合律)
        - [赋值运算优先级较低](#赋值运算优先级较低)
        - [复合赋值运算符](#复合赋值运算符)
    - [4.5 递增和递减运算符](#45-递增和递减运算符)
        - [解引用和递增运算符](#解引用和递增运算符)
        - [运算对象求值顺序不确定](#运算对象求值顺序不确定)
    - [4.6 成员访问运算符](#46-成员访问运算符)
    - [4.7 条件运算符](#47-条件运算符)
        - [练习4.24 条件运算符改变结合性](#练习424-条件运算符改变结合性)
    - [4.8 位运算符](#48-位运算符)
        - [位运算符表](#位运算符表)
        - [移位运算符](#移位运算符)
        - [位求反运算符](#位求反运算符)
        - [使用位运算符的例子](#使用位运算符的例子)
        - [移位运算符满足左结合律](#移位运算符满足左结合律)
        - [练习4.26：unsigned long 和 unsigned int的位宽](#练习426unsigned-long-和-unsigned-int的位宽)
    - [4.9 sizeof运算符](#49-sizeof运算符)
        - [利用sizeof运算获得数组的大小](#利用sizeof运算获得数组的大小)
    - [4.10 逗号运算符](#410-逗号运算符)
    - [4.11 类型转换](#411-类型转换)
        - [隐式转换 (implicit conversion)](#隐式转换-implicit-conversion)
        - [4.11.1 算术转换](#4111-算术转换)
            - [整数提升](#整数提升)
            - [无符号类型的运算对象](#无符号类型的运算对象)
            - [类型转换的例子](#类型转换的例子)
        - [4.11.2 其他隐式类型转换](#4112-其他隐式类型转换)
            - [数组转换成指针](#数组转换成指针)
            - [指针的转换](#指针的转换)
            - [转换成bool类型](#转换成bool类型)
            - [转换成常量](#转换成常量)
            - [类类型定义的转换](#类类型定义的转换)
        - [4.11.3 显示转换 (explitit conversions)](#4113-显示转换-explitit-conversions)
            - [命名的强制类型转换 Named Casts](#命名的强制类型转换-named-casts)
            - [旧式的强制类型转换](#旧式的强制类型转换)
    - [4.12 运算符优先级表](#412-运算符优先级表)

<!-- /TOC -->

# 第四章 表达式

## 4.1 基础

### 4.1.1 基本概念

- 一元运算符：取地址符&，解引用符*
- 二元运算符：相等运算==，乘法运算*
- 三元运算符
- 函数调用也是一种特殊的运算符，运算对象数量没有限制

### 4.1.2 优先级和结合律

### 4.1.3 求值顺序

优先级规定运算对象的组合方式，但是没有规定求值顺序。大多数情况下不会指明求值顺序。

```cpp
int m = f1() * f2();
```

例如上述表达式我们就不知道是`f1()`先调用还是`f2()`。如果两个函数都修改同一个对象那么就会引发错误，产生未定义的行为。

例如：

```cpp
int i=0;
cout << i << " " << ++i << endl;
```

上述输出表达式是未定义的，不同编译器可能做出不同的操作。这种表达式的行为不可预知，所以是错误的。

有四种运算符明确规定了运算对象的求值顺序：

- 逻辑与`&&`，先求左边，左边为真才求右边
- 逻辑或`||`
- 条件运算符`?:`
- 逗号运算符`,`

处理复合表达式的两个建议：

- 拿不准的时候使用括号强制让表达式的组合关系符合程序的逻辑需求。

- 如果改变了某个运算对象的值，那么表达式的其他部分不要再使用这个对象。

`*++iter`先递增，再解引用

## 4.2 算术运算符

![](https://tva1.sinaimg.cn/large/7e197809ly1g34do3l4unj20yi0cvwgo.jpg)

算符优先级从上到下依次减小。左结合律表示：优先级相同时按照从左到右的顺序进行组合。

- 一元符号运算符对运算对象取负后，返回其提升后的副本

```cpp
int i = 1024;
int k = -i;   // k = -1024

bool b = true;
bool b2 = -b; // b2 = true
```

对大多数运算符来说，bool对象被转换为int类型；b为true，那么转换为1；b2则为-1，-1不为0，所以b2为true。

- C++11规定除法运算中，如果两个运算对象符号不相同则商为负，且规定商向0取整（直接切除小数部分）。

```cpp
int a1 = -9;
int b1 = 2;
cout << a1/b1 << endl;

int a2 = 9;
int b2 = -5;
cout << a2/b2 << endl;
```

上述结果分别为-4， -1.

- C++新标准中，要求`(-m)/n`和`m/(-n)`都等于`-(m/n)`

- `m%(-n)`相当于`m%n`，`(-m)%n`相当于`-(m%n)`

例子如下：

```
21 % 6 = 3
21 % 7 = 0
-21 % -8 = -5     // 相当于-21 % 8 -> - (21 % 8) = -5
21 % -5 = 1

21 / 6 = 3
21 / 7 = 3
-21 / -8 = 2      // 相当于 -21 / -8 -> 21 / 8 = 2
21 / -5 = -4      // 相当于 - (21 / 5) = -4
```

### 练习4.6 一个表达式判断一个数是奇数还是偶数

```
i % 2 == 0 ? "odd" : "even";
```

### 练习4.7 三条导致溢出的语句

```cpp
int main()
{
    short a = 32767; // short为16位，2^8 = 32768，正数部分为0~32767
    cout << ++a << endl;

    unsigned n = 0;
    cout << --n << endl;

    unsigned short m = 65535; // 2^16 = 65536
    cout << ++m << endl;
}

// output is：
// -32768
// 4294967295
// 0
```

## 4.3 逻辑和关系运算符

- 关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。

- 他们的返回值都是布尔类型。

- 运算对象和求值结果都是 ***右值*** 。

![](https://tva1.sinaimg.cn/large/7e197809gy1g35veefqqpj20vw0eun04.jpg)

### 逻辑与，逻辑或

这两种逻辑运算符都会先计算左边的值，如果左边的值不能确定表达式的结果才会集散右边对象的值。这种策略称为**短路求值(short-circuit evaluation)**

一个使用逻辑或运算符的例子：

>涉及到`some_tips`中对常量的引用

s被声明为了对常量的引用，在这里因为text的内容是string对象，可能非常大。所以把s声明成引用可以避免对元素的拷贝。由于不需要对s进行写，所以声明成对常量的引用。

```cpp
for (const auto &s: text){
    cout << s;
    if (s.empty() || s[s.size()-1] == '.') cout << endl;
    else cout << " ";
}
```

### 关系运算符

关系运算符都满足 ***左结合律***

表达式 `if(i < j < k)` 表示当k>1时候，if为真。

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可修改的左值。

其中C++11新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象。

```
int k = {3.14};  // warning, 发生了窄值转换
```

其中，如果左侧运算对象是内置类型（int）,那么初始值列表最多只能包含一个值，并且该值即使转换其所占空间也不应该大于目标类型的空间。

窄值转换(narrow conversion)在C++11中报错为：

```bash
tempCodeRunnerFile.cpp: In function 'int main()':
tempCodeRunnerFile.cpp:7:18: warning: narrowing conversion of '3.1400000000000001e+0' from 'double' to 'int' inside { } [-Wnarrowing]
     int k = {3.14};
```

### 赋值运算满足右结合律

***赋值运算满足右结合律，返回左侧运算对象。***

```cpp
int a, b;
a = b = 3;
```

由于赋值运算满足右结合律，所以靠右的赋值运算`b = 3`作为左侧赋值运算符的右侧运算对象。又因为赋值运算返回的是其左侧运算对象，所以右侧赋值计算的运算结果b赋值给了a。

### 赋值运算优先级较低

赋值运算符的优先级低于关系运算符的优先级，通常需要加括号。

```cpp
while ( (c = getchar()) != 'A'){
    cout << c << endl;
}
```

### 复合赋值运算符

`a += 1` 和 `a = a+1`

使用复合赋值运算符只求值一次，使用普通的运算符求值两次。对程序性能的些许影响可以忽略不计。

## 4.5 递增和递减运算符

这两个运算符可以用于迭代器。递增和递减运算符有两种形式：

- 前缀形式：首先将运算对象+1或者-1，然后将改变后的对象作为求值结果。

- 后缀形式：将运算对象+1或者-1，求值结果是运算对象改变之前的副本。

建议使用前置版本而不是后置版本。因为后置版本会保存原始值，操作浪费。

### 解引用和递增运算符

`*pbeg++`：后置递增运算符的优先级高于解引用运算符，所以相当于`*(pbeg++)`，即获取`pbeg`位置的元素，并将指针向前移动一个位置。

### 运算对象求值顺序不确定

大多数运算符没有规定运算对象的求值顺序。递增递减运算符会改变运算对象的值，提防在复合表达式中错用这两个运算符。

例如：`*beg = toupper(*beg++)`，赋值运算符左右两侧的运算对象都使用了beg，右边运算对象还改变了beg的值，所以该赋值语句是未定义的。

## 4.6 成员访问运算符

点运算符和箭头运算符都可以用于访问成员。点运算符用于获取类对象的一个成员，箭头运算符和点运算符有关，`ptr->mem`相当于`(*ptr).mem`。

```cpp
string s1 = "hello, world", *p = &s1;
auto n = s1.size();
n = (*p).size();  // 解引用的优先级低于点运算符
n = p->size();
```

## 4.7 条件运算符

`cond ? expr1 : expr2`

例如：

```cpp
finalgraade = (grade > 90) ? "high" : (grade < 60) ? "low" : "medium"
```

条件运算符的优先级很低，所以条件运算符通常需要加括号。

```cpp
cout << ((grade < 60) ? "high" : "low") << endl;

// (grade < 60)的比较结果是 << 运算符的运算对象，如果(grade < 60)为真，则输出1，否则输出0.
// << 运算符的返回值是cout，所以cout作为条件运算符的条件，此时表达式相当于：
// cout ? "high" : "low"; 根据cout的值是true还是false来产生对应的字面值。而cout是一个对象，无所谓值。
cout << (grade < 60) ? "high" : "low" << endl;

// 先输出grade，随后是 cout < 60 ? "high" : "low".
// 试图比较cout和60，错误。
cout << grade < 60 ? "high" : "low" << endl;
```

条件运算符的结合性是 ***右结合*** 的，即 `a?b:c?d:e` 为 `a?b:(c?d:e)` ，即靠右边的条件运算构成了靠左边的条件运算的分支。

若它是左结合的话，上述条件表达式加括号应为`(a?b:c)?d:e`.

>参考链接：https://www.zhihu.com/question/266172062

### 练习4.24 条件运算符改变结合性

```cpp
finalgrade = (grade > 90) ? "high pass" :
                            (grade < 60) ? "fail" : "pass";
```

如果条件运算符变为左结合律，该表达式会变为：

```cpp
finalgrade = ((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass";
```

此时c++11会报错：

```c++
error: operands to ?: have different types 'const char*' and 'bool'
finalgrade = ((grade > 90) ? "high pass" : (grade < 60)) ? "fail" : "pass";
                           ^
```

## 4.8 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成二进制位的集合。

### 位运算符表

运算符 | 功能 
--- | ---
~ | 求反
<< | 左移
>> | 右移
& | 与
^ | 异或
| | 或

如果运算对象是小整形，那么会被提升到较大的整数类型。例如**练习4.25**中`char`提升到`int`。

运算对象可以带符号也可以不带符号，如果运算对象带符号且它的值为负，如何处理运算对象的符号位依赖于机器，此时，***左移操作*** 可能会改变符号位的值，所以这是一种 ***未定义*** 的行为。

关于符号位如何操作没有明确规定，强烈建议将位运算处理无符号类型。

### 移位运算符

移位运算符右侧的运算对象不为负，值必须小于结果的位数，否则会产生未定义的行为。且向左右移出边界的部分被舍弃掉。

```cpp
unsigned char bits = 0233; // 假定char占8为，int占32为，bits二进制表示为 10011011
// 若要对bits进行移位，首先将它提升到int类型

bits << 31;
// 提升到int类型之后是 00000000 00000000 00000000 10011011
// 左移31位，左侧被舍弃掉，结果为 10000000 00000000 00000000 00000000

bits >> 3;
// 向右移动3位，右侧的3位被舍弃掉，结果为 00000000 00000000 00000000 00010011
```

- 左移运算符：在右侧插入值为0的二进制位

- 右移运算符：如果运算对象是无符号类型，在左侧插入值为0的二进制位；若运算对象有符号，在左侧插入符号位的副本或者0，根据具体环境决定。如果是正数，左边补0，如果是负数，左边补1。

例子：

对-7进行右移1位。

负数在计算机中以补码的形式存储，若要求得-7在计算机中的补码，需要从+7来求。

1. +7的原码为 `00000111`

2. 补码为原码取反+1 `11111001`

3. 对补码进行右移一位，由于是负数，左边补上1，结果为 `11111100` ，即为-7在计算机中的表示

4. 对结果取补码，可以获得结果的相反数的原码，结果为 `00000100` ，为4

5. 所以-7右移一位结果为-4

### 位求反运算符

逐位求反，char被提升为int。

### 使用位运算符的例子

假设班级有30个学生，使用每一位为0或者1代表该学生是否通过考试。

`unsigned long quiz = 0;`

此时quiz代表所有学生都没通过考试。

如果第27个学生通过了考试，那么我们就让一个数值第27位为1，其他位为0，然后这个值与quiz进行或运算。

```cpp
unsigned long pass27 = 1 << 27;
```

用字面值表示为：`1UL << 27`.

进行或运算表示该学生通过了测试：`quiz |= 1UL << 27`

设置该学生没有通过测试，需要让第27位为0，其他位为1，然后与quiz进行与运算。

字面值表示为：`~(1UL << 27)`

设置第27位为0：`quiz &= ~(1UL << 27)`

检查第27名学生是否通过了测试：`bool test27 = quiz & (1UL << 27)`

### 移位运算符满足左结合律

进行IO操作的重载运算符结合律和它的内置版本相同，即移位运算符满足左结合律。

移位运算符优先级比算术运算符低，比关系运算符，条件运算符，赋值运算符优先级高。

### 练习4.26：unsigned long 和 unsigned int的位宽

>https://zh.cppreference.com/w/cpp/language/types

![](https://tva1.sinaimg.cn/large/7e197809ly1g3iaeqy762j20lu0903yz.jpg)

- unsigned int 至少为16位

- unsigned long 至少为32位

## 4.9 sizeof运算符

sizeof运算符返回一个表达式或者一个类型名字所占的字节数，类型为`size_t`。运算符运算对象的两种形式`sizeof (type)`或者`sizeof expr`.

例子：

```cpp
Sales_data *p;

sizeof *p;
```

sizeof满足右结合律，而且和*运算符优先级相同，所以表达式会按照从右到左的顺序组合，即`sizeof (*p)`。而且sizeof不会求运算对象的值，所以指针未初始化也没什么影响。

即：在sizeof运算符中解引用无效指针是一个安全的行为，因为指针实际上并没有被真正使用。

### 利用sizeof运算获得数组的大小

```cpp
int a = [20];

constexpr size_t sz = sizeof(a) / (sizeof(*a))；
int arr[sz]; // 正确，sizeof返回一个常量表达式
```

## 4.10 逗号运算符

逗号表达式(comma operator)含有两个运算对象，按照从左到右的顺序依次求值。

首先对左侧表达式求值，然后将左侧的求值结果丢掉，**逗号运算符的真正结果是右侧表达式的值**。

## 4.11 类型转换

如果两种类型可以相互转换 (conversion)，那么他们就是关联的。C++ 语言不会直接将两个不同类型的值相加，而是先根据类型转换规则将运算对象的类型统一后再求值。

### 隐式转换 (implicit conversion)

自动执行的转换，例如： `int ival = 3.541 + 3;` ，3转换成 double ，将加法运算得到的 double 类型转换为 int 类型。

### 4.11.1 算术转换

算术转换 (arithmetic conversion) 的含义是把一种算术类型转换成另一种算术类型。

其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是 long double ，那么所有的类型都会转换成 long double。

#### 整数提升

整数提升 (integral promotion) 负责把小整数类型转换成较大的整数类型，对于 bool, char, unsigned char, signed char, short, unsigned short 等类型来说，只要他们所有可能的值都能存到 int 中，他们就会提升成 int 类型。否则提升到 unsigned int 类型。

较大的 char 类型 (wchar_t, char16_t, char32_t) 提升成 int, unsigned int, long, unsigned long, long long, unsigned long long 中最小的一种类型。

转换后的类型需要容纳原类型所有可能的值。

#### 无符号类型的运算对象

如果运算符的运算对象类型不一致，那么需要转换成相同的类型。

如果某个运算对象是无符号类型，那么转换的结果要依赖于机器中各个整数类型的相对大小。

- 如果两个运算对象类型都是带符号的或者无符号的，则小类型的运算对象转换成较大的类型。

- 一个是无符号一个是带符号，且无符号类型不小于带符号类型，则带符号类型转换成无符号类型。例如：int 转换为 unsigned int。（存在副作用，见2.1.2节）

- 带符号类型大于无符号类型，则转换结果依赖于机器。如果无符号类型都能存到带符号类型中，则无符号转换为带符号。否则相反。例如，如果 unsigned int 和 long 大小相同，那么 long 转换为 unsigned int；如果 long 占用的空间比 int 大，则 unsigned int 转换为 long。

#### 类型转换的例子

```cpp
3.14159L + 'a';     // a promoted to int, int converted to long double
dval + ival;        // ival converted to double
dval + fval;        // fval converted to double
ival = dval;        // dval converted to int (by truncation 切除小数部分)
flag = dval;        // dval == 0 ? false : true;
cval + fval;        // cval promoted to int, int converted to float
sval + cval;        // sval and cval promoted to int
cval + lval;        // cval converted to long
ival + ulval;       // ival converted to unsigned long
usval + ival;       // 类型转换根据 unsigned short 和 int 的字节长度来确定
uival + lval;       // 根据 unsigned int 和 long 的字节长度来确定
```

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：

```cpp
int ia[10];
int *p = ia;  // ia转换成指向数组首元素的指针
```

当数组被用作 `decltype`, 取地址符 `&`, `sizeof`, `typeid` 等运算符的运算对象时，数组不会被转换成指针。

#### 指针的转换

- 常量整数值 0 和字面值 nullptr 可以转换成任意指针类型
 
- 指向任意非常量的指针能够转换成 void*

- 指向任意对象的指针能转换成 const void*

#### 转换成bool类型

存在从算术类型或指针类型向布尔类型自动转换的机制。

```cpp
char *cp = 0;        // cp 为空指针，不指向任何实际的对象
char *cp = nullptr;  // nullptr 用来表示空指针常量
if (cp) ...          // 上述两个指针值都不会使该条件语句执行 
```

#### 转换成常量

允许将指向非常量类型的指针 转换成 指向相应的常量类型的指针。（引用同理）

```cpp
int i;
const int &j = i;      // 非常量 i 转换成 const int 的引用
const int *p = &i;     // 非常量 i 的地址转换成 const 的地址
int &r = j, *q = p;    // 错误，不允许将 const 转换成 非常量 conversion from const to nonconst not allowed
```

#### 类类型定义的转换

类类型能定义由编译器自动执行的转换。

- 在标准库 string 类型的地方使用C风格字符串。

```cpp
string s = "a value"；  // 字符串字面值转换成 string 类型
```

- while() 条件部分转换为布尔类型

```cpp
while (cin >> s) // while 的条件部分把 cin 转换成 bool 类型，IO库定义了 istream 到 bool类型转换的规则
```

### 4.11.3 显示转换 (explitit conversions)

强制转换类型 cast 。尽管有时候不得不使用强制类型转换，但这种方法本质上是十分危险的。

#### 命名的强制类型转换 Named Casts

一个命名的强制类型转换有如下格式： `cast-name<type>(expression)`

其中 `type` 是转换的目标，`expression` 是转换的值，如果 `type` 是引用类型，那么结果是左值。`cast-name` 制定了执行哪种转换。

- static_cast

任何具有明确定义的类型转换，只要不包含底层const（指针指向对象是个常量），都可以使用static_cast。

例如，将一个运算对象强制转换为 doubke 类型来执行浮点数除法。

```cpp
int i, j;
double dval = static_cast<double>(j) / i;
```

可以使用 static_cast 找回存在于 void* 指针中的值：

```cpp
void *p = &d; // 任何非常量对象的地址都能存到void*

double *dp = static_cast<double*>(p);  // 将void*转换回初始的指针类型
```

当把指针存到 void* 中，并且用 static_cast 将其强制转换回原来的类型时，应该确保指针的值保持不变。转换的结果与原始的地址值相等，所以我们必须确保转换后所得的类型就是指针所指的类型。

- const_cast 

只能改变运算对象的底层const（指针指向对象是一个常量）。

```cpp
const char *pc;
char *p = const_cast<char*>(pc);
```

将常量对象转换为非常量对象的行为，称为 “去掉const性质” (cast away the const)。

只有 const_cast 能改变表达式的常量属性，但不能改变表达式的类型。

```cpp
const char *cp = "hello, world";
char *q = static_cast<char *>(cp);    // error, static_cast cant cast away const
static_cast<string>(cp);              // 正确，字符串字面值可以转换成string类型
const_cast<string>(cp)；              // 错误，const_cast 只能改变常量属性
```

const_cast 常用于有关函数重载的上下文中，见6.4节。

- reinterpret_cast

reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。

#### 旧式的强制类型转换

早期的C++语言中，显示地进行强制类型转换包含两种形式：

- `type (expr);`  // 函数形式的强制类型转换，例如，int(a)

- `(type) expr;`  // C语言风格的强制类型转换，例如，(int)a

## 4.12 运算符优先级表

![](https://tva1.sinaimg.cn/large/7e197809ly1g5a7l2kh9vj20mn0ltgpu.jpg)

![](https://tva1.sinaimg.cn/large/7e197809ly1g5a7lvpd90j20on0y5jyg.jpg)

