<!-- TOC -->

- [第四章 表达式](#第四章-表达式)
    - [4.1 基础](#41-基础)
        - [4.1.1 基本概念](#411-基本概念)
        - [4.1.2 优先级和结合律](#412-优先级和结合律)
        - [4.1.3 求值顺序](#413-求值顺序)
    - [4.2 算术运算符](#42-算术运算符)
        - [练习4.6 一个表达式判断一个数是奇数还是偶数](#练习46-一个表达式判断一个数是奇数还是偶数)
        - [练习4.7 三条导致溢出的语句](#练习47-三条导致溢出的语句)
    - [4.3 逻辑和关系运算符](#43-逻辑和关系运算符)
        - [逻辑与，逻辑或](#逻辑与逻辑或)
        - [关系运算符](#关系运算符)
    - [4.4 赋值运算符](#44-赋值运算符)
        - [赋值运算满足右结合律](#赋值运算满足右结合律)
        - [赋值运算优先级较低](#赋值运算优先级较低)
        - [复合赋值运算符](#复合赋值运算符)
    - [4.5 递增和递减运算符](#45-递增和递减运算符)
        - [解引用和递增运算符](#解引用和递增运算符)
        - [运算对象求值顺序不确定](#运算对象求值顺序不确定)
    - [4.6 成员访问运算符](#46-成员访问运算符)
    - [4.7 条件运算符](#47-条件运算符)
    - [4.8 位运算符](#48-位运算符)

<!-- /TOC -->

# 第四章 表达式

## 4.1 基础

### 4.1.1 基本概念

- 一元运算符：取地址符&，解引用符*
- 二元运算符：相等运算==，乘法运算*
- 三元运算符
- 函数调用也是一种特殊的运算符，运算对象数量没有限制

### 4.1.2 优先级和结合律

### 4.1.3 求值顺序

优先级规定运算对象的组合方式，但是没有规定求值顺序。大多数情况下不会指明求值顺序。

```cpp
int m = f1() * f2();
```

例如上述表达式我们就不知道是`f1()`先调用还是`f2()`。如果两个函数都修改同一个对象那么就会引发错误，产生未定义的行为。

例如：

```cpp
int i=0;
cout << i << " " << ++i << endl;
```

上述输出表达式是未定义的，不同编译器可能做出不同的操作。这种表达式的行为不可预知，所以是错误的。

有四种运算符明确规定了运算对象的求值顺序：

- 逻辑与`&&`，先求左边，左边为真才求右边
- 逻辑或`||`
- 条件运算符`?:`
- 逗号运算符`,`

处理复合表达式的两个建议：

- 拿不准的时候使用括号强制让表达式的组合关系符合程序的逻辑需求。

- 如果改变了某个运算对象的值，那么表达式的其他部分不要再使用这个对象。

`*++iter`先递增，再解引用

## 4.2 算术运算符

![](https://ws1.sinaimg.cn/large/7e197809ly1g34do3l4unj20yi0cvwgo.jpg)

算符优先级从上到下依次减小。左结合律表示：优先级相同时按照从左到右的顺序进行组合。

- 一元符号运算符对运算对象取负后，返回其提升后的副本

```cpp
int i = 1024;
int k = -i;   // k = -1024

bool b = true;
bool b2 = -b; // b2 = true
```

对大多数运算符来说，bool对象被转换为int类型；b为true，那么转换为1；b2则为-1，-1不为0，所以b2为true。

- C++11规定除法运算中，如果两个运算对象符号不相同则商为负，且规定商向0取整（直接切除小数部分）。

```cpp
int a1 = -9;
int b1 = 2;
cout << a1/b1 << endl;

int a2 = 9;
int b2 = -5;
cout << a2/b2 << endl;
```

上述结果分别为-4， -1.

- C++新标准中，要求`(-m)/n`和`m/(-n)`都等于`-(m/n)`

- `m%(-n)`相当于`m%n`，`(-m)%n`相当于`-(m%n)`

例子如下：

```
21 % 6 = 3
21 % 7 = 0
-21 % -8 = -5     // 相当于-21 % 8 -> - (21 % 8) = -5
21 % -5 = 1

21 / 6 = 3
21 / 7 = 3
-21 / -8 = 2      // 相当于 -21 / -8 -> 21 / 8 = 2
21 / -5 = -4      // 相当于 - (21 / 5) = -4
```

### 练习4.6 一个表达式判断一个数是奇数还是偶数

```
i % 2 == 0 ? "odd" : "even";
```

### 练习4.7 三条导致溢出的语句

```cpp
int main()
{
    short a = 32767; // short为16位，2^16 = 32768，正数部分为0~32767
    cout << ++a << endl;

    unsigned n = 0;
    cout << --n << endl;

    unsigned short m = 65535; // 2^16 = 65536
    cout << ++m << endl;
}

// output is：
// -32768
// 4294967295
// 0
```

## 4.3 逻辑和关系运算符

- 关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。

- 他们的返回值都是布尔类型。

- 运算对象和求值结果都是 ***右值*** 。

![](https://ws1.sinaimg.cn/large/7e197809gy1g35veefqqpj20vw0eun04.jpg)

### 逻辑与，逻辑或

这两种逻辑运算符都会先计算左边的值，如果左边的值不能确定表达式的结果才会集散右边对象的值。这种策略称为**短路求值(short-circuit evaluation)**

一个使用逻辑或运算符的例子：

>涉及到`some_tips`中对常量的引用

s被声明为了对常量的引用，在这里因为text的内容是string对象，可能非常大。所以把s声明成引用可以避免对元素的拷贝。由于不需要对s进行写，所以声明成对常量的引用。

```cpp
for (const auto &s: text){
    cout << s;
    if (s.empty() || s[s.size()-1] == '.') cout << endl;
    else cout << " ";
}
```

### 关系运算符

关系运算符都满足 ***左结合律***

表达式 `if(i < j < k)` 表示当k>1时候，if为真。

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可修改的左值。

其中C++11新标准允许使用花括号括起来的初始化列表作为赋值语句的右侧运算对象。

```
int k = {3.14};  // warning, 发生了窄值转换
```

其中，如果左侧运算对象是内置类型（int）,那么初始值列表最多只能包含一个值，并且该值即使转换其所占空间也不应该大于目标类型的空间。

窄值转换(narrow conversion)在C++11中报错为：

```bash
tempCodeRunnerFile.cpp: In function 'int main()':
tempCodeRunnerFile.cpp:7:18: warning: narrowing conversion of '3.1400000000000001e+0' from 'double' to 'int' inside { } [-Wnarrowing]
     int k = {3.14};
```

### 赋值运算满足右结合律

***赋值运算满足右结合律，返回左侧运算对象。***

```cpp
int a, b;
a = b = 3;
```

由于赋值运算满足右结合律，所以靠右的赋值运算`b = 3`作为左侧赋值运算符的右侧运算对象。又因为赋值运算返回的是其左侧运算对象，所以右侧赋值计算的运算结果b赋值给了a。

### 赋值运算优先级较低

赋值运算符的优先级低于关系运算符的优先级，通常需要加括号。

```cpp
while ( (c = getchar()) != 'A'){
    cout << c << endl;
}
```

### 复合赋值运算符

`a += 1`和`a = a + 1`

使用复合赋值运算符只求值一次，使用普通的运算符求值两次。对程序性能的些许影响可以忽略不计。

## 4.5 递增和递减运算符

这两个运算符可以用于迭代器。递增和递减运算符有两种形式：

- 前缀形式：首先将运算对象+1或者-1，然后将改变后的对象作为求值结果。

- 后缀形式：将运算对象+1或者-1，求值结果是运算对象改变之前的副本。

建议使用前置版本而不是后置版本。因为后置版本会保存原始值，操作浪费。

### 解引用和递增运算符

`*pbeg++`：后置递增运算符的优先级高于解引用运算符，所以相当于`*(pbeg++)`，即获取`pbeg`位置的元素，并将指针向前移动一个位置。

### 运算对象求值顺序不确定

大多数运算符没有规定运算对象的求值顺序。递增递减运算符会改变运算对象的值，提防在复合表达式中错用这两个运算符。

例如：`*beg = toupper(*beg++)`，赋值运算符左右两侧的运算对象都使用了beg，右边运算对象还改变了beg的值，所以该赋值语句是未定义的。

## 4.6 成员访问运算符

点运算符和箭头运算符都可以用于访问成员。点运算符用于获取类对象的一个成员，箭头运算符和点运算符有关，`ptr->mem`相当于`(*ptr).mem`。

```cpp
string s1 = "hello, world", *p = &s1;
auto n = s1.size();
n = (*p).size();  // 解引用的优先级低于点运算符
n = p->size();
```

## 4.7 条件运算符

`cond ? expr1 : expr2`

例如：

```cpp
finalgraade = (grade > 90) ? "high" : (grade < 60) ? "low" : "medium"
```

条件运算符的优先级很低，所以条件运算符通常需要加括号。

```cpp
cout << ((grade < 60) ? "high" : "low") << endl;

// (grade < 60)的比较结果是 << 运算符的运算对象，如果(grade < 60)为真，则输出1，否则输出0.
// << 运算符的返回值是cout，所以cout作为条件运算符的条件，此时表达式相当于：
// cout ? "high" : "low"; 根据cout的值是true还是false来产生对应的字面值。而cout是一个对象，无所谓值。
cout << (grade < 60) ? "high" : "low" << endl;

// 先输出grade，随后是 cout < 60 ? "high" : "low".
// 试图比较cout和60，错误。
cout << grade < 60 ? "high" : "low" << endl;
```

## 4.8 位运算符