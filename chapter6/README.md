<!-- TOC -->

- [第六章 函数](#第六章-函数)
    - [6.1 函数基础](#61-函数基础)
        - [调用函数](#调用函数)
        - [形参和实参](#形参和实参)
        - [函数的形参列表](#函数的形参列表)
        - [函数返回类型](#函数返回类型)
        - [6.1.1 局部对象](#611-局部对象)
            - [自动对象](#自动对象)
            - [局部静态对象](#局部静态对象)
        - [6.1.2 函数声明](#612-函数声明)
            - [在头文件中进行函数声明](#在头文件中进行函数声明)
        - [6.1.3 分离式编译](#613-分离式编译)
            - [编译和链接多个源文件](#编译和链接多个源文件)
    - [6.2 参数传递](#62-参数传递)

<!-- /TOC -->

# 第六章 函数

## 6.1 函数基础

一个函数包括以下部分：

- 返回类型 (return type)

- 函数名

- 由0个或多个形参(parameter)组成的列表

- 函数体(function body)

使用 **调用运算符 (call operator)** 来执行函数。调用运算符是一对圆括号，作用于一个表达式，该表达式是 **函数** 或者 **指向函数的指针**。

### 调用函数

函数的调用完成两项工作：

1. 用实参初始化函数对应的形参

2. 将控制权转移给被调用函数；主调函数 (calling function) 的执行被暂时中断，被调函数 (called function) 开始执行。

执行函数的第一步：

1. 隐式的定义并初始化形参

遇到 return 的执行过程：

1. 返回 return 语句中的值

2. 将控制权从被调函数转移回到主函数

### 形参和实参

1. 实参和形参存在对应关系，但是没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。

2. 实参的类型必须和形参的类型匹配

### 函数的形参列表

1. 函数的形参列表可以为空，为了和C语言兼容，也可以使用关键字 void 表示函数没有形参。

2. 即使两个形参类型一样，也必须把两个类型都写出来。

```cpp
int f (int a, int b)
{
    ...
}
```

### 函数返回类型

- 返回类型为 void ，表示函数不返回任何值。

- 返回类型不能为数组或者函数类型，但是可以为 **指向数组的指针** 或 **指向函数的指针** 。

### 6.1.1 局部对象

函数体是一个语句块，块构成一个新的作用域，我们可以在内部定义变量。

形参和函数体内定义的变量统称为局部变量(local variable)，仅在函数作用域内可见，若有重名变量，则函数体内变量起作用。

#### 自动对象

只存在于块执行期间的对象称为 **自动对象** (automatic object)。

形参是一种自动对象，对于局部变量对应的自动对象来说：

1. 如果变量定义本身含有初始值，就用这个初始值初始化；

2. 变量定义本身不含有初始值，执行默认初始化。产生未定义的值。

>p40 定义在函数体内的内置类型变量将不被初始化，一个未被初始化的内置类型变量的值是未定义的。

#### 局部静态对象

使用 `static` 定义的对象。

局部静态对象(local static object) 在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。

如果局部静态变量没有显式初始值，执行值 **初始化** ，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数只能定义一次，但是可以声明多次。如果一个函数没有被用到，那么它可以只有声明没有定义。

函数声明示例：

`void print(vector<int>::const_iterator begin, vector<int>::const_iterator end);`

#### 在头文件中进行函数声明

函数应该在头文件中声明，在源文件中定义。

### 6.1.3 分离式编译

C++ 支持分离式编译(seperate compilation)。分离式编译允许我们把程序分割到几个文件中去。

#### 编译和链接多个源文件

如果 face 函数定义在一个 face.cc 文件中，声明位于 Chapter6.h 文件中。

face.cc 文件应该包含 Chapter6.h 头文件。

在 faceMain.cc 的文件中创建 main 函数，main 函数将调用 face 函数。

对于上述步骤，若要使用 g++ 编译器生成可执行文件：

```bash
$ g++ faceMain.cc face.cc  # generate faceMain.exe or a.out
$ g++ faceMain.cc face.cc -o main # generate main or main.exe
```

如果只修改了一个源文件，那么我们只需要重新编译改动了的文件。编译器提供了分离式编译每个文件的机制，这一过程通常会产生后缀名为 `.obj` 或者 `.o` 的文件，后缀名含义是该文件包含 对象代码 (object code)。

接下来编译器负责链接。

```bash
$ g++ -c faceMain.cc # generate faceMain.o
$ g++ -c face.cc # generate face.o
$ g++ faceMain.o face.o # generate faceMain.exe or a.out
$ g++ faceMain.o face.o -o main # generate main.exe or main
```

## 6.2 参数传递