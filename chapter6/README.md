<!-- TOC -->

- [第六章 函数](#第六章-函数)
    - [6.1 函数基础](#61-函数基础)
        - [调用函数](#调用函数)
        - [形参和实参](#形参和实参)
        - [函数的形参列表](#函数的形参列表)
        - [函数返回类型](#函数返回类型)
        - [6.1.1 局部对象](#611-局部对象)
            - [自动对象](#自动对象)
            - [局部静态对象](#局部静态对象)
        - [6.1.2 函数声明](#612-函数声明)
            - [在头文件中进行函数声明](#在头文件中进行函数声明)
        - [6.1.3 分离式编译](#613-分离式编译)
            - [编译和链接多个源文件](#编译和链接多个源文件)
    - [6.2 参数传递](#62-参数传递)
        - [6.2.1 传值 参数](#621-传值-参数)
            - [指针形参](#指针形参)
        - [6.2.2 传引用 参数](#622-传引用-参数)
            - [使用引用避免拷贝](#使用引用避免拷贝)
            - [使用引用形参返回额外信息](#使用引用形参返回额外信息)
        - [6.2.3 const 形参和实参](#623-const-形参和实参)
            - [const 和 指针，引用形参](#const-和-指针引用形参)
            - [尽量使用常量引用](#尽量使用常量引用)
        - [6.2.4 数组形参](#624-数组形参)
            - [传递数组形参的大小](#传递数组形参的大小)
                - [使用标记指定数组长度](#使用标记指定数组长度)
                - [使用标准库规范](#使用标准库规范)
                - [显式传递一个表示数组大小的形参](#显式传递一个表示数组大小的形参)
            - [数组引用形参](#数组引用形参)
            - [传递多维数组](#传递多维数组)

<!-- /TOC -->

# 第六章 函数

## 6.1 函数基础

一个函数包括以下部分：

- 返回类型 (return type)

- 函数名

- 由0个或多个形参(parameter)组成的列表

- 函数体(function body)

使用 **调用运算符 (call operator)** 来执行函数。调用运算符是一对圆括号，作用于一个表达式，该表达式是 **函数** 或者 **指向函数的指针**。

### 调用函数

函数的调用完成两项工作：

1. 用实参初始化函数对应的形参

2. 将控制权转移给被调用函数；主调函数 (calling function) 的执行被暂时中断，被调函数 (called function) 开始执行。

执行函数的第一步：

1. 隐式的定义并初始化形参

遇到 return 的执行过程：

1. 返回 return 语句中的值

2. 将控制权从被调函数转移回到主函数

### 形参和实参

1. 实参和形参存在对应关系，但是没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。

2. 实参的类型必须和形参的类型匹配

### 函数的形参列表

1. 函数的形参列表可以为空，为了和C语言兼容，也可以使用关键字 void 表示函数没有形参。

2. 即使两个形参类型一样，也必须把两个类型都写出来。

```cpp
int f (int a, int b)
{
    ...
}
```

### 函数返回类型

- 返回类型为 void ，表示函数不返回任何值。

- 返回类型不能为数组或者函数类型，但是可以为 **指向数组的指针** 或 **指向函数的指针** 。

### 6.1.1 局部对象

函数体是一个语句块，块构成一个新的作用域，我们可以在内部定义变量。

形参和函数体内定义的变量统称为局部变量(local variable)，仅在函数作用域内可见，若有重名变量，则函数体内变量起作用。

#### 自动对象

只存在于块执行期间的对象称为 **自动对象** (automatic object)。

形参是一种自动对象，对于局部变量对应的自动对象来说：

1. 如果变量定义本身含有初始值，就用这个初始值初始化；

2. 变量定义本身不含有初始值，执行默认初始化。产生未定义的值。

>p40 定义在函数体内的内置类型变量将不被初始化，一个未被初始化的内置类型变量的值是未定义的。

#### 局部静态对象

使用 `static` 定义的对象。

局部静态对象(local static object) 在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。

如果局部静态变量没有显式初始值，执行值 **初始化** ，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数只能定义一次，但是可以声明多次。如果一个函数没有被用到，那么它可以只有声明没有定义。

函数声明示例：

`void print(vector<int>::const_iterator begin, vector<int>::const_iterator end);`

#### 在头文件中进行函数声明

函数应该在头文件中声明，在源文件中定义。

### 6.1.3 分离式编译

C++ 支持分离式编译(seperate compilation)。分离式编译允许我们把程序分割到几个文件中去。

#### 编译和链接多个源文件

如果 face 函数定义在一个 face.cc 文件中，声明位于 Chapter6.h 文件中。

face.cc 文件应该包含 Chapter6.h 头文件。

在 faceMain.cc 的文件中创建 main 函数，main 函数将调用 face 函数。

对于上述步骤，若要使用 g++ 编译器生成可执行文件：

```bash
$ g++ faceMain.cc face.cc  # generate faceMain.exe or a.out
$ g++ faceMain.cc face.cc -o main # generate main or main.exe
```

如果只修改了一个源文件，那么我们只需要重新编译改动了的文件。编译器提供了分离式编译每个文件的机制，这一过程通常会产生后缀名为 `.obj` 或者 `.o` 的文件，后缀名含义是该文件包含 对象代码 (object code)。

接下来编译器负责链接。

```bash
$ g++ -c faceMain.cc # generate faceMain.o
$ g++ -c face.cc # generate face.o
$ g++ faceMain.o face.o # generate faceMain.exe or a.out
$ g++ faceMain.o face.o -o main # generate main.exe or main
```

## 6.2 参数传递

- 形参为引用类型：绑定到对应的实参上。实参被引用传递 (passed by reference)，函数被传引用调用 (called by reference)。

- 形参为非引用类型：将实参的值拷贝后赋值给形参。形参和实参是两个独立的对象，这样的实参被值传递 (passed by value)，函数被传值调用 (called by value)。

### 6.2.1 传值 参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。

#### 指针形参

当执行指针拷贝操作时，拷贝的是指针的值，和两个指针是不同的指针，但是访问的对象相同也可以修改。

例如，使用函数交换两个数的值：

```cpp
void swap (int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

C++ 中建议使用引用类型的形参代表指针，来访问函数外部的变量。

### 6.2.2 传引用 参数

通过引用形参，可以让函数改变一个或者多个实参的值。

例如，利用函数重置一个值为0：

```cpp
void reset(int &i)
{
    i = 0;
}
```

#### 使用引用避免拷贝

拷贝大的类类型对象比较低效，甚至有的类类型就不支持拷贝(IO类型)。

例如，string 对象可能比较长，使用引用形参避免拷贝：

```cpp
bool compare(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```

其中，如果函数无需改变引用形参的值，那么最好将其声明为常量引用。

#### 使用引用形参返回额外信息

若一个函数想要返回多个信息，可以定义一个新的数据类型，或者使用引用形参可以一次返回多个结果。

### 6.2.3 const 形参和实参

顶层const 作用于对象本身，当用实参初始化形参时，会忽略掉 顶层const。当形参有 顶层const 时，传给他常量对象或者非常量对象都可以。

忽略掉顶层const的一个缺陷：在C++中允许函数名字相同，形参不同。但是由于忽略掉顶层const，所以如下定义是重复定义

```cpp
void f(const int i);
void f(int i);
```

由于顶层const 被忽略掉，所以他们的形参一样。

#### const 和 指针，引用形参

可以使用非常量初始化一个底层 const 对象。

#### 尽量使用常量引用

把函数不会改变的形参定义长引用是一种比较常见的错误，这种做法会带来一种误导：函数可以修改它的实参的值。

使用引用而非常量引用会限制函数能接受的实参类型：不能把 const 对象，字面值传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质让我们在定义和使用数组上的函数有影响：

- 不允许拷贝数组，所以不能以值传递的方式使用数组参数。所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

- 使用数组时通常会转换成指针。

其中，三个等价的传递数组的参数：

```cpp
void print(const int*);
void print(const int[]);
void print(const int[10]);    // 这里体现了我们期望数组有多少元素，实际数量不一定。
```

上述三个函数调用时，只检查传入的参数是否为 `const int*` 类型。

例如:

```cpp
int i = 0, j[2] = {0, 1};
print(&i); // true
print(j);  // true
```

以数组作为形参的函数必须保证使用数组时不会越界。

#### 传递数组形参的大小

数组是以指针形式传递给函数的，所以一开始函数不知道数组的确切尺寸。传递数组形参的大小有三种方式。

##### 使用标记指定数组长度

要求数组本身包含一个结束标记，例如C风格字符串：C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符`\0`。

```cpp
void print(const char *cp)
{
    if (cp)         // 如果cp不是一个空指针
    {
        while (*cp) cout << *cp++;  // 当cp不是一个空字符'\0'，打印并向前移动一个位置
    }
}
```

##### 使用标准库规范

传递指向数组首元素和尾后元素的指针。

```cpp
void print(const int *begin, const int *end)
{
    while (begin != end)
     cout << *begin++ << endl;
}
```

为了调用这个函数，需要传递两个指针：指向首元素和指向结尾元素下一个元素的指针。

```cpp
int j[2] = {0, 1};
print(std::begin(j), std::end(j));
```

##### 显式传递一个表示数组大小的形参

专门定义一个表示数组大小的形参。

```cpp
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i)
    {
        cout << ia[i] << endl;
    }
}
```

调用的时候必须传入数组的大小。

```cpp
int j[] = {1, 2};
print(j, std::end(j) - std::begin(j));
```

#### 数组引用形参

C++ 允许将变量定义为数组的引用，形参也可以是数组的引用。

```cpp
void print(int (&arr)[10])
{
    for (auto i : arr)
        cout << i << endl;
}
```

其中，arr 两端的括号不可少。

- `int &arr[10]` 表示有10个 int 引用的数组

- `int (&arr)[10]` 表示 arr 是引用，类型为 int ，大小为10，即大小为10的 int 类型数组

然而这种方法限制了 print 函数的可用性，只能将函数作用于大小为10的数组：

若要传入数组 `int j[2] = {0, 1};`，会报错：

```
error: invalid initialization of reference of type 'const int (&)[10]' from expression of type 'int [2]'
```

#### 传递多维数组

```cpp
void print(int (*matrix)[10], int rowSize)；
// 等价定义
void print(int matrix[][10], int rowSize); // 从声明看起来是二维数组，实际是指向含有10个整数的数组的指针
```

其中，matrix 指向数组的首元素，数组的每个元素都是大小为10的数组。

*matrix 两端的括号不可少：

- `int *matrix[10];` 表示 matrix 是 int* 类型的数组，大小为10

- `int (*matrix)[10];` 表示 matrix 是指针，指向 int 类型大小为10的数组