
# 第十八章 用于大型程序的工具

## 18.2 命名空间

- 命名空间污染(namespace pollution)：多个库将名字放置在全局命名空间中。

- 命名空间(namespace)分隔了全局命名空间，每个命名空间是一个作用域。

### 18.2.1 命名空间定义

命名空间的定义包含两部分：

- 关键字 `namespace`

- 命名空间的名字，名字后面是一系列由花括号括起来的声明和定义，花括号之后无需加分号

```cpp
namespace cpp_primer {
    class Sales_data { /* ... */ };
    Sales_data operator+(const Sales_data&, const Sales_data&);
    class Query { };
    class Query_base { };
} // 命名空间结束之后无序加分号
```

命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中。

#### 每个命名空间都是一个作用域

- 命名空间中的每个名字都必须表示该空间内的唯一实体。

- 不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。

- 定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。

- 位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间。

例如：

```cpp
cppprimer::Query q = cppprimer::Query("hello");
```

#### 命名空间可以是不连续的

命名空间可以定义在几个不同的地方。

例如如下声明：

```cpp
namespace nsp {

}
```

可能是定义了一个新的命名空间，也可能是为之前已经存在的命名空间添加新的成员。

- 这个特性可以让我们将几个独立的接口和实现文件组成一个命名空间：

1. 命名空间的一部分成员用来定义类，声明类的接口，这些成员应该置于头文件中。

2. 命名空间成员的定义部分置于另外的源文件中。

#### 定义本书的命名空间

- 通常情况下，我们不把 `#include` 放在命名空间的内部。

例如对于 Sales_data 类：

```cpp
// ------ Sales_data.h --------
#include <string>

namespace cpp_primer {
    class Sales_data {};
    Sales_data operator+(const Sales_data&, const Sales_data&);
}

// ------- Sales_data.cc --------
#include "Sales_data.h"

namespace cpp_primer {
    
    // 头文件中的实现
    Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) {
        // ...
    }
}
```

若在程序中使用我们定义的库，需要指定命名空间：

```cpp
// ------ user.cc ------
#include "Sales_data.h"
int main()
{
    using cpp_primer::Sales_data;
    Sales_data s1, s2;
    // ...
}
```

#### 定义命名空间的成员

可以在命名空间作用域内定义成员，直接使用名字无需前缀。

可以在命名空间外部定义成员，此时命名空间对名字的声明必须在作用域内，该名字的定义必须明确指出所属的命名空间。

#### 模板特例化

>占坑

#### 全局命名空间

全局作用域中定义的名字，即在所有类、函数、 命名空间之外定义的名字，定义在全局命名空间中(global namespace)。

全局命名空间以隐式的方式声明，并且在所有的程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。

作用域运算符可以作用域全局命名空间 `::member_name` 表示全局命名空间中的一个成员。

#### 嵌套的命名空间

嵌套的命名空间内层的名字将隐藏外层的同名成员。

外层想要访问内层中的名字需要在名字前加限定符。

#### 内联命名空间

C++11 引入了 **内联命名空间(inline namespace)**。

- 内联命名空间中的名字可以被外层命名空间直接使用。

- 定义内联命名空间的方式是在关键字 `namespace` 前添加关键字 `inline`。

- 关键字 `inline` 必须出现在命名空间第一次定义的地方，后续打开命名空间的时候可写可不写。

```cpp
// ------ FifthEdi.h ------
inline namespace FifthEdi { // 第五版的内联命名空间
    // ...
}

namespace FifthEdi {  // 隐式内联
    class Query_base { };
}
```

当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。

例如：我们可以把本书当前版本的所有代码放入内联命名空间，之前版本的代码放入非内联命名空间：

```cpp
// ----- FourthEdi.h ------
namespace FourthEdi { // 第四版为非内联命名空间
    class Item_base { };
    class Query_base { };
}
```

我们的命名空间 `cpp_primer` 可以同时使用这两个命名空间：

```cpp
namespace cpp_primer {
#include "FifthEdi.h"
#include "FourthEdi.h"
}
```

因为 `FifthEdi` 是内联的命名空间，所以之前使用 `cpp_primer::` 的代码可以直接获得 `FifthEdi` 的成员。

若使用较早版本的代码，必须加上完整的命名空间，例如：`cpp_primer::FourthEdi::Query_base`。

#### 未命名的命名空间

**未命名的命名空间(unnamed namespace)** 指关键字 `namespace` 后紧跟花括号括起来的一系列声明语句。

- 未命名的命名空间中定义的变量拥有 **静态生命周期**：他们在第一次使用前创建，直到程序结束才销毁。

- 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。

若两个文件都有未命名的命名空间，则两个空间相互无关。两个未命名的命名空间中可以定义相同的名字，并且表示不同的实体。

如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同的实体。

- 即：未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。

- 定义在未命名的命名空间中的名字可以直接使用，不能使用域运算符。

- 如果未命名的命名空间定义在文件的最外层作用域中，则该名字一定要与全局作用域中的名字有所区别：

例如：

```cpp
int i;
namespace {
    int i;
}

i = 10; // ambiguous
```

- 未命名的命名空间的成员可以通过嵌套它的命名空间的名字来访问：

```cpp
namespace local {
    namespace {
        int i;
    }
}

local::i = 42;
```

#### 使用未命名的命名空间取代文件中的静态声明

标准 C++ 引入命名空间的概念之前，程序需要将名字声明成 static 以使得其对整个文件有效。静态声明从 C 语言继承而来的。C 语言中，声明为 static 的全局实体在其所在的文件外不可见。

C++ 中应使用未命名的命名空间。